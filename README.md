# DADS6005_Project
# group member
# design diagram
# 1. consumer
{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "view-in-github",
        "colab_type": "text"
      },
      "source": [
        "<a href=\"https://colab.research.google.com/github/kittipat7/DADS6005_Project/blob/main/consumer.ipynb\" target=\"_parent\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open In Colab\"/></a>"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "sIBOQypnz-V0"
      },
      "outputs": [],
      "source": [
        "%%capture\n",
        "!pip install confluent_kafka\n",
        "!pip install plotly\n",
        "!pip install chart_studio\n",
        "!pip install skforecast"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "1Yv00x1DwMdo"
      },
      "outputs": [],
      "source": [
        "from confluent_kafka import Consumer, KafkaError\n",
        "import json\n",
        "import time\n",
        "import numpy as np\n",
        "import pandas as pd\n",
        "import matplotlib.pyplot as plt\n",
        "from IPython.display import display, clear_output\n",
        "from sklearn.linear_model import LinearRegression\n",
        "from sklearn.linear_model import Lasso\n",
        "from sklearn.ensemble import RandomForestRegressor\n",
        "from sklearn.metrics import mean_squared_error\n",
        "from sklearn.preprocessing import StandardScaler\n",
        "from sklearn.pipeline import make_pipeline\n",
        "from skforecast.ForecasterAutoreg import ForecasterAutoreg\n",
        "from skforecast.ForecasterAutoregCustom import ForecasterAutoregCustom\n",
        "from skforecast.ForecasterAutoregDirect import ForecasterAutoregDirect\n",
        "from skforecast.model_selection import grid_search_forecaster\n",
        "from skforecast.model_selection import backtesting_forecaster\n",
        "from skforecast.utils import save_forecaster\n",
        "from skforecast.utils import load_forecaster\n",
        "from sklearn.preprocessing import MinMaxScaler\n",
        "\n",
        "\n",
        "# Set up the Kafka consumer for topic 1\n",
        "c1 = Consumer({\n",
        "    'bootstrap.servers': 'ec2-13-229-46-113.ap-southeast-1.compute.amazonaws.com:9092',\n",
        "    'group.id': 'my-consumer-group',\n",
        "    'auto.offset.reset': 'latest'\n",
        "})\n",
        "c1.subscribe(['eth1'])\n",
        "# Set up the Kafka consumer for topic 2\n",
        "c2 = Consumer({\n",
        "    'bootstrap.servers': 'ec2-13-229-46-113.ap-southeast-1.compute.amazonaws.com:9092',\n",
        "    'group.id': 'mygroup',\n",
        "    'auto.offset.reset': 'latest'\n",
        "})\n",
        "c2.subscribe(['btc1'])\n",
        "\n",
        "btc=[]\n",
        "eth=[]\n",
        "btc_var=[]\n",
        "eth_var=[]\n",
        "i=1\n",
        "i2=1\n",
        "x_count=[]\n",
        "x_count2=[]\n",
        "err_sqr_btc=[]\n",
        "err_sqr_eth=[]\n",
        "mse_btc=[]\n",
        "mse_eth=[]\n",
        "\n",
        "# Consume messages from Kafka and print them to the console\n",
        "while True:\n",
        "    msg1 = c1.poll(1.0)\n",
        "\n",
        "    if msg1 is None:\n",
        "        continue\n",
        "    if msg1.error():\n",
        "        print(\"Consumer error: {}\".format(msg1.error()))\n",
        "        continue\n",
        "    msg2 = c2.poll(1.0)\n",
        "\n",
        "    if msg2 is None:\n",
        "        continue\n",
        "    if msg2.error():\n",
        "        print(\"Consumer error: {}\".format(msg2.error()))\n",
        "        continue\n",
        "    \n",
        "\n",
        "    # Print the message from topic 1\n",
        "    a=msg1.value().decode('utf-8')\n",
        "    b=json.loads(a)\n",
        "    eth.append(b[\"USD\"])\n",
        "    print(\"ETH :\",b[\"USD\"])\n",
        "    # Print the message from topic 2\n",
        "    c=msg2.value().decode('utf-8')\n",
        "    d=json.loads(c)\n",
        "    bpi = d['bpi']\n",
        "    bpi_USD=bpi[\"USD\"]\n",
        "\n",
        "    btc.append(bpi_USD[\"rate_float\"])\n",
        "    print(\"BTC :\",bpi_USD[\"rate_float\"])\n",
        "    btc_var.append(np.var(btc))\n",
        "    eth_var.append(np.var(eth))\n",
        "    #counter\n",
        "    x_count.append(i)\n",
        "\n",
        "    #print variance and create data frame of varince\n",
        "    datadict = {'period':x_count,'BTC': btc_var, 'ETH': eth_var}\n",
        "    df = pd.DataFrame(datadict)\n",
        "    if len(btc)<2:\n",
        "      df.plot(x=\"period\", y=[\"BTC\", \"ETH\"])\n",
        "    #model\n",
        "    if len(btc)>=2:\n",
        "      datadict2 = {'period':x_count,'BTC': btc, 'ETH': eth}\n",
        "      df2= pd.DataFrame(datadict2)\n",
        "\n",
        "    #BTC_model\n",
        "      forecaster = ForecasterAutoreg(\n",
        "                regressor = RandomForestRegressor(random_state=123),\n",
        "                lags      = len(btc)-1\n",
        "             )\n",
        "\n",
        "      forecaster.fit(y=df2[\"BTC\"])\n",
        "      from multiprocessing.sharedctypes import Value\n",
        "      steps = 1\n",
        "      predictions = forecaster.predict(steps=steps)\n",
        "      btc_pred = predictions.item()\n",
        "    #ETH_model\n",
        "      forecaster2 = ForecasterAutoreg(\n",
        "                regressor = RandomForestRegressor(random_state=123),\n",
        "                lags      = len(eth)-1\n",
        "             )\n",
        "\n",
        "      forecaster2.fit(y=df2[\"ETH\"])\n",
        "      from multiprocessing.sharedctypes import Value\n",
        "      steps = 1\n",
        "      predictions2 = forecaster2.predict(steps=steps)\n",
        "      eth_pred = predictions2.item()\n",
        "      \n",
        "      err_sqr_btc.append((predictions.item()-bpi_USD[\"rate_float\"])**2)\n",
        "      err_sqr_eth.append((predictions2.item()-b[\"USD\"])**2)\n",
        "\n",
        "      mse_btc.append(sum(err_sqr_btc)/len(err_sqr_btc))\n",
        "      mse_eth.append(sum(err_sqr_eth)/len(err_sqr_eth))\n",
        "\n",
        "      x_count2.append(i2)\n",
        "      datadict_mse = {'period':x_count2,'BTC_MSE': mse_btc, 'ETH_MSE': mse_eth}\n",
        "      df_mse= pd.DataFrame(datadict_mse)\n",
        "\n",
        "      #Normalization BTC MSE and ETH MSE\n",
        "      scaler2 = StandardScaler()   \n",
        "      scaler2.fit(df_mse)\n",
        "      df_scaled2 = scaler2.transform(df_mse)\n",
        "      df_scaled2 = pd.DataFrame(df_scaled2, columns=df_mse.columns)\n",
        "      \n",
        "      #Normalization BTC Variance and ETH Variance\n",
        "      scaler = StandardScaler()\n",
        "      scaler.fit(df)\n",
        "      df_scaled = scaler.transform(df)\n",
        "      df_scaled = pd.DataFrame(df_scaled, columns=df.columns)\n",
        "\n",
        "      #Visualize\n",
        "      fig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(15, 5))\n",
        "      plt.subplots_adjust(wspace=0.5)\n",
        "      ax1.set_title('Compare Variance between BTC and ETH')\n",
        "      ax2.set_title('Compare MSE between BTC and ETH')\n",
        "\n",
        "      df_scaled.plot(x=\"period\", y=[\"BTC\", \"ETH\"],ax=ax1)\n",
        "      df_scaled2.plot(x=\"period\", y=[\"BTC_MSE\", \"ETH_MSE\"],ax=ax2)\n",
        "      print(\"ETH_var :\",df_scaled.tail(1)['BTC'].item())\n",
        "      print(\"BTC_var :\",df_scaled.tail(1)['ETH'].item())\n",
        "      print(\"BTC_pred :\",predictions.item())\n",
        "      print(\"ETH_pred :\",predictions2.item())\n",
        "      print(\"mse_btc :\",df_scaled2.tail(1)['BTC_MSE'].item())\n",
        "      print(\"mse_eth :\",df_scaled2.tail(1)['ETH_MSE'].item())\n",
        "      i2+=1\n",
        "\n",
        "    plt.show()\n",
        "    clear_output(wait=True)\n",
        "    i+=1\n",
        "    time.sleep(60)\n",
        "\n",
        "c.close()"
      ]
    }
  ],
  "metadata": {
    "colab": {
      "provenance": [],
      "authorship_tag": "ABX9TyNQ00SNxNDGPEFGSam89RxD",
      "include_colab_link": true
    },
    "kernelspec": {
      "display_name": "Python 3",
      "name": "python3"
    },
    "language_info": {
      "name": "python"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 0
}
# 2. producer1
# 3. producer2
# Api
https://min-api.cryptocompare.com/data/price

https://api.coindesk.com/v1/bpi/currentprice.json
